# -*- coding: utf8 -*-


# Практическое задание
# 1 Создать список и заполнить его элементами различных типов данных. Реализовать скрипт проверки типа данных каждого элемента.
# Использовать функцию type() для проверки типа.
# Элементы списка можно не запрашивать у пользователя, а указать явно, в программе.
list_different_elements = [False,
                           1,
                           1.24,
                           'string',
                           [1, 2, 3, 4],
                           (1, 'list', True),
                           set('rrrtttyyyerterertrt'),
                           dict(k_1='val_1', k_2='val_2'),
                           bytearray(b"some text"),
                           ]

for element in list_different_elements:
    print(f'Тип элемента:{type(element)}, элемент:{element}')

# 2 Для списка реализовать обмен значений соседних элементов, т.е.
# Значениями обмениваются элементы с индексами 0 и 1, 2 и 3 и т.д.
# При нечетном количестве элементов последний сохранить на своем месте.
# Для заполнения списка элементов необходимо использовать функцию input().

data_list = []
new_data_list = []
new_element = str()
while True:
    new_element = input('Введите элемент, если хотите закончить введите: x\n')
    if new_element is 'x':
        break
    data_list.append(new_element)

print(f'Перед сменой мест:{data_list}')
for key, element in enumerate(data_list):
    if key % 2:
        new_data_list.append(element)
        new_data_list.append(element_1)
        odd = False
    else:
        odd = True
        element_1 = element
if odd:
    new_data_list.append(element)

print(f'После смены мест:{new_data_list}')


# 3 Пользователь вводит месяц в виде целого числа от 1 до 12.
# Сообщить к какому времени года относится месяц (зима, весна, лето, осень). Напишите решения через list и через dict.


month_season_list = [[1, 'зима'], [2, 'зима'], [12, 'зима'],
                     [3, 'весна'], [4, 'весна'], [5, 'весна'],
                     [6, 'лето'], [7, 'лето'], [8, 'лето'],
                     [9, 'осень'], [10, 'осень'], [11, 'осень']
                     ]
month_season_dict = {1: 'зима', 2: 'зима', 12: 'зима',
                     3: 'весна', 4: 'весна', 5: 'весна',
                     6: 'лето', 7: 'лето', 8: 'лето',
                     9: 'осень', 10: 'осень', 11: 'осень'
                     }

month_user_str = input('Скажи ка... дядя/тётя... какой нибудь номер месяца\n')
if month_user_str.isnumeric() and (int(month_user_str) > 0 and int(month_user_str) <= 12):
    month_user_int = int(month_user_str)
    for data_list in month_season_list:
        month, season = data_list
        if month is month_user_int:
            print(f'А сезон то {season} #Реализация со списком')
            break

    print(f'А сезон то {month_season_dict[month_user_int]} #Реализация словарём')

else:
    print(f'Введённый номер месяца "{month_user_str}" не верен. Нужно число от 1 до 12 включительно')


# 4 Пользователь вводит строку из нескольких слов, разделённых пробелами.
# Вывести каждое слово с новой строки. Строки необходимо пронумеровать.
# Если в слово длинное, выводить только первые 10 букв в слове.

# words_from_str = 'dsfsdf выаф ыфыв афывафывпdfasd fывапыва выап'.split()

words_from_str = input('Введите произвольную строку\n').split()

for id,word in enumerate(words_from_str):
    print('{} {}'.format(id, word[0:10]))


# 5 Реализовать структуру «Рейтинг», представляющую собой не возрастающий набор натуральных чисел.
# У пользователя необходимо запрашивать новый элемент рейтинга.
# Если в рейтинге существуют элементы с одинаковыми значениями, то новый элемент с тем же значением должен разместиться после них.
# Подсказка. Например, набор натуральных чисел: 7, 5, 3, 3, 2.
# Пользователь ввел число 3. Результат: 7, 5, 3, 3, 3, 2.
# Пользователь ввел число 8. Результат: 8, 7, 5, 3, 3, 2.
# Пользователь ввел число 1. Результат: 7, 5, 3, 3, 2, 1.
# Набор натуральных чисел можно задать непосредственно в коде, например, my_list = [7, 5, 3, 3, 2].

list = [7, 5, 3, 3, 2]

print(list)
new_natural_num_str = input('Введите натуральное число\n')
if new_natural_num_str.isnumeric():
    new_natural_num_int = int(new_natural_num_str)
    for id, from_list_num in enumerate(list):
        if new_natural_num_int >= from_list_num:
            list.insert(id, new_natural_num_int)
            break
        elif len(list) == id + 1:
            list.insert(id + 1, new_natural_num_int)

    print(list)
else:
    print('Введённые данные не корректны!')


# 6 Реализовать структуру данных «Товары». Она должна представлять собой список кортежей.
# Каждый кортеж хранит информацию об отдельном товаре.
# В кортеже должно быть два элемента — номер товара и словарь с параметрами (характеристиками товара: название, цена, количество, единица измерения).
# Структуру нужно сформировать программно, т.е. запрашивать все данные у пользователя.
# [
#    (1, {“название”: “компьютер”, “цена”: 20000, “количество”: 5, “eд”: “шт.”}),
#    (2, {“название”: “принтер”, “цена”: 6000, “количество”: 2, “eд”: “шт.”}),
#    (3, {“название”: “сканер”, “цена”: 2000, “количество”: 7, “eд”: “шт.”})
# ]
# Пример готовой структуры:
# Необходимо собрать аналитику о товарах. Реализовать словарь, в котором каждый ключ — характеристика товара, например название, а значение — список значений-характеристик, например список названий товаров.
##Пример:
# {
#    “название”: [“компьютер”, “принтер”, “сканер”],
#    “цена”: [20000, 6000, 2000],
#    “количество”: [5, 2, 7],
#    “ед”: [“шт.”]
# }

# Формируем список кортежей запрашивая у пользователя данные
i = 1
big_data_list = []
while True:
    data_temp = tuple(input('Ведите список через запятую содержащий: '
                            '"название товара",цену,количество,единицы\n Exit: x\n').split(','))
    if data_temp[0] is 'x':
        break
    # Проверяем данные, а именно, только цифры и количество элементов
    if len(data_temp) == 4 and data_temp[1].isnumeric() and data_temp[2].isnumeric():
        dict_data_temp = {  'название': data_temp[0],
                            'цена': data_temp[1],
                            'количество': data_temp[2],
                            'ед.': data_temp[3]
                            }
        big_data_list.append((i, dict_data_temp))
        i += 1
    else:
        print('Введённые данные не правильные пожалуйста ещё раз\n')

#big_data_list = [(1, {'название': 'яблоко', 'цена': '10', 'количество': '5', 'ед.': 'шт'}),
#                 (2, {'название': 'молоко', 'цена': '13', 'количество': '2', 'ед.': 'литр'}),
#                 (3, {'название': 'зелень', 'цена': '199', 'количество': '4', 'ед.': 'кг'})]
parsed_data = {}
for element_big_data in big_data_list:
    id, data_dict = element_big_data
    for key_elem_data in data_dict.keys():
        if parsed_data.get(key_elem_data) is not None:
            parsed_data[key_elem_data].append(data_dict.get(key_elem_data))
        else:
            parsed_data[key_elem_data] = [data_dict.get(key_elem_data)]

print(parsed_data)
